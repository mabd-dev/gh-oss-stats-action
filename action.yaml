# =========
name: gh-oss-stats
description: Generate Badge To Showcase Your Open Source Contributions
author: mabd-dev

branding:
  icon: 'award'
  color: 'green'


# ============= INPUTS ==============
inputs:
  mode:
    description: 'Operation mode: "fetch" to get stats, "badge" to generate badge, "full" to fetch and generate badge'
    required: false
    default: 'full'

  username: 
    description: Github username
    default: ${{ github.repository_owner }}

  github-token:
    description: Github Token for API access
    required: true

  include-loc:
    description: Include LOC (Lines Of Code) metrics
    default: 'true'

  min-stars:
    description: Minimum repo stars
    default: '0'

  max-prs:
    description: Max PRs to fetch
    default: '500'

  exclude-orgs:
    description: Comma-separated list of organizations to exclude
    default: ""

  timeout:
    description: Timeout in seconds
    default: '300'

  verbose:
    description: 'Enable verbose logging for debugging'
    default: 'false'

  debug:
    description: Uses fake data when true
    default: 'false'

  # ==== Badge Flags ====
  badge-style:
    default: 'summary'

  badge-variant:
    default: 'default'

  badge-theme:
    default: 'dark'

  badge-output-path:
    description: Output path for the badge
    default: 'oss-stats.svg'

  badge-sort:
    default: 'prs'

  badge-limit:
    default: '5'

  # ==== Action Flags ====
  commit-badge:
    description: 'Automatically commit and push the generated badge'
    default: 'true'

  commit-message:
    description: Commit message when auto-commit badge
    default: 'Update OSS contribution badge'

  version:
    description: Version of mabd-dev/gh-oss-stats to use
    default: latest

  data:
    description: 'JSON stats data (from fetch mode output)'
    required: false


# ============= OUTPUTS ==============
outputs:
  json:
    description: 'JSON stats data (only set in fetch mode)'
    value: ${{ steps.fetch.outputs.json }}

# ============ EXECUTION ============
runs:
  using: 'composite'
  steps:

    - name: Download gh-oss-stats
      shell: bash
      run: |
        echo "::group::Installing gh-oss-stats binary"
        
        OS=$(uname -s | tr '[:upper:]' '[:lower:]')  # Linux -> linux, Darwin -> darwin
        ARCH=$(uname -m)
        
        # Map architecture names
        case "$ARCH" in
          x86_64)  ARCH="amd64" ;;
          aarch64) ARCH="arm64" ;;
          arm64)   ARCH="arm64" ;;  # macOS reports arm64 directly
          *)
            echo "::error::Unsupported architecture: $ARCH"
            exit 1
            ;;
        esac
        
        BINARY="gh-oss-stats-${OS}-${ARCH}"
        
        # Validate supported combinations
        case "$BINARY" in
          gh-oss-stats-linux-amd64|gh-oss-stats-linux-arm64|gh-oss-stats-darwin-arm64)
            echo "Downloading $BINARY..."
            ;;
          *)
            echo "::error::Unsupported platform: ${OS}/${ARCH}"
            echo "::error::Supported: linux/amd64, linux/arm64, darwin/arm64"
            exit 1
            ;;
        esac
        
        curl -fSL -o gh-oss-stats \
          "https://github.com/mabd-dev/gh-oss-stats/releases/latest/download/${BINARY}"
        chmod +x gh-oss-stats
        
        echo "✅ Installed $BINARY"
        echo "::endgroup::"


    - name: Fetch Stats
      if: inputs.mode == 'fetch'
      id: fetch
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.github-token }}
      run: |
        ./gh-oss-stats \
          --user ${{ inputs.username }} \
          --include-loc=${{ inputs.include-loc }} \
          --min-stars ${{ inputs.min-stars }} \
          --max-prs ${{ inputs.max-prs }} \
          --exclude-orgs "${{ inputs.exclude-orgs }}" \
          --verbose=${{ inputs.verbose }} \
          --timeout ${{ inputs.timeout }} \
        > /tmp/stats.json

        # Export to output
        echo "json<<EOF" >> $GITHUB_OUTPUT
        cat /tmp/stats.json >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT

    - name: Generate Badge
      if: inputs.mode == 'badge'
      id: badge
      shell: bash
      env:
        STATS_DATA: ${{ inputs.data }}
      run: |
        # Debug: Check if data was received
        if [ -z "$STATS_DATA" ]; then
          echo "::error::No data received in 'data' input"
          echo "::error::Make sure the previous 'fetch' step succeeded and outputs.json was set"
          exit 1
        fi

        echo "::group::Debug JSON Data"
        echo "Data length: ${#STATS_DATA} characters"
        echo "First 500 chars of received data:"
        echo "$STATS_DATA" | head -c 500
        echo ""
        echo "::endgroup::"

        # Write JSON data to file, preserving exact content
        printf '%s' "$STATS_DATA" > /tmp/stats.json

        # Validate file was created
        if [ ! -f /tmp/stats.json ]; then
          echo "::error::Failed to create /tmp/stats.json"
          exit 1
        fi

        echo "Created /tmp/stats.json ($(wc -c < /tmp/stats.json) bytes)"

        ./gh-oss-stats badge \
          --from-file '/tmp/stats.json' \
          --badge-style ${{ inputs.badge-style }} \
          --badge-variant ${{ inputs.badge-variant }} \
          --badge-theme ${{ inputs.badge-theme }} \
          --badge-sort ${{ inputs.badge-sort }} \
          --badge-output ${{ inputs.badge-output-path }} \
          --badge-limit ${{ inputs.badge-limit }}


        if [ ! -f "${{ inputs.badge-output-path }}" ]; then
          echo "::error::Badge file was not created at ${{ inputs.badge-output-path }}"
          exit 1
        fi

        BADGE_SIZE=$(stat -f%z "${{ inputs.badge-output-path }}" 2>/dev/null || stat -c%s "${{ inputs.badge-output-path }}" 2>/dev/null)
        echo "✅ Badge generated successfully ($BADGE_SIZE bytes)"

    - name: Fetch & Generate badge
      if: inputs.mode == 'full'
      shell: bash
      id: full
      env:
        GITHUB_TOKEN: ${{ inputs.github-token }}
      run: |
        echo "::group::Generating OSS contribution badge"

        ./gh-oss-stats \
          --user ${{ inputs.username }} \
          --include-loc=${{ inputs.include-loc }} \
          --min-stars ${{ inputs.min-stars }} \
          --max-prs ${{ inputs.max-prs }} \
          --exclude-orgs "${{ inputs.exclude-orgs }}" \
          --verbose=${{ inputs.verbose }} \
          --timeout ${{ inputs.timeout }} \
          --debug=${{ inputs.debug }} \
          --badge \
          --badge-style ${{ inputs.badge-style }} \
          --badge-variant ${{ inputs.badge-variant }} \
          --badge-theme ${{ inputs.badge-theme }} \
          --badge-sort ${{ inputs.badge-sort }} \
          --badge-output ${{ inputs.badge-output-path }} \
          --badge-limit ${{ inputs.badge-limit }}

        if [ ! -f "${{ inputs.badge-output-path }}" ]; then
          echo "::error::Badge file was not created at ${{ inputs.badge-output-path }}"
          exit 1
        fi
        
        BADGE_SIZE=$(stat -f%z "${{ inputs.badge-output-path }}" 2>/dev/null || stat -c%s "${{ inputs.badge-output-path }}" 2>/dev/null)
        echo "✅ Badge generated successfully ($BADGE_SIZE bytes)"
        echo "::endgroup::"

    - name: Commit changes
      if: inputs.commit-badge == 'true' && inputs.mode != 'fetch'
      uses: stefanzweifel/git-auto-commit-action@v5
      with:
        commit_message: ${{ inputs.commit-message }}
        file_pattern: ${{ inputs.badge-output-path }}
